package com.bofa.protocol.communication.mqtt.task;import com.bofa.protocol.codec.util.ByteBufUtils;import com.bofa.protocol.communication.mqtt.store.ClientSessionManager;import io.netty.buffer.ByteBuf;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import java.math.BigDecimal;import java.util.concurrent.TimeUnit;/** * @author bofa1ex * @since 2020/4/20 */public class ReSendPublishTask {    static final Logger logger = LoggerFactory.getLogger(ReSendPublishTask.class);    /** 默认20秒过期, 消息需要重发 */    static final long DEFAULT_EXPIRE_INTERVAL_TIME = TimeUnit.SECONDS.toMillis(20);    @Autowired    private ClientSessionManager clientSessionManager;    /** 执行时间10s */    @Scheduled(fixedRateString = "PT10S")    public void reSendPayload() {        clientSessionManager.entryStream()                // 过滤packetIdPayloadEntries不为空                .filter(entry -> entry.getValue().getPacketIdPayloadEntries().size() > 0)                .forEach(entry -> {                    final String clientId = entry.getKey();                    final ClientSessionManager.ClientSession clientSession = entry.getValue();                    clientSession.getPacketIdPayloadEntries().parallelStream()                            // 检查是否过期, 需要重发                            .filter(packetIdPayloadEntry -> {                                final long interval = System.currentTimeMillis() - packetIdPayloadEntry.getTimestamp() - DEFAULT_EXPIRE_INTERVAL_TIME;                                logger.info("离过期还差 [{}ms]", Math.abs(interval));                                return interval > 0;                            })                            .forEach(packetIdPayloadEntry -> {                                final Integer packetId = packetIdPayloadEntry.getPacketId();                                final ByteBuf payload = packetIdPayloadEntry.getPayload();                                final String data = ByteBufUtils.buffer2HexNonRead(payload);                                logger.info("[clientId: {}] 重发 [packetId: {}] [[payload: {}]", clientId, packetId, data);                                clientSession.getChannel().writeAndFlush(payload);                            });                });    }}