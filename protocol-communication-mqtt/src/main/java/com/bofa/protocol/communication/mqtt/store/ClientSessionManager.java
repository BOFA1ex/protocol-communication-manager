package com.bofa.protocol.communication.mqtt.store;import com.bofa.protocol.codec.mqtt.MqttParser;import com.bofa.protocol.codec.mqtt.model.*;import com.bofa.protocol.codec.util.ByteBufUtils;import com.github.benmanes.caffeine.cache.Cache;import com.github.benmanes.caffeine.cache.Caffeine;import io.netty.buffer.ByteBuf;import io.netty.channel.Channel;import io.netty.util.AttributeKey;import io.netty.util.ReferenceCountUtil;import lombok.Builder;import lombok.Getter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.time.Duration;import java.util.*;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicReference;import java.util.stream.Stream;/** * @author bofa1ex * @since 2020/4/19 */public class ClientSessionManager {    static final Logger logger = LoggerFactory.getLogger(ClientSession.class);    static final AttributeKey<String> CLIENT_ID_ATTRIBUTE_KEY = AttributeKey.newInstance("CLIENT_ID");    @Autowired    private MqttParser mqttParser;    @Resource(name = "businessExecutor")    protected ThreadPoolTaskExecutor executor;    private Cache<String, ClientSession> clientSessionCache;    @PostConstruct    public void init(){        clientSessionCache = Caffeine.newBuilder()                // 这里踩坑了, dispatch本是指定走executor, 由于caffeine未指定executor, 走默认ForkJoinPool.commonPool                .executor(executor)                .initialCapacity(2 << 6)                .maximumSize(2 << 7)                .recordStats()                .build();    }    public Stream<Map.Entry<String, ClientSession>> entryStream() {        return clientSessionCache.asMap().entrySet().parallelStream();    }    public String getClientId(Channel channel) {        return channel.attr(CLIENT_ID_ATTRIBUTE_KEY).get();    }    public void dispatch(MqttPublishPacket data) {        final String topicName = data.getTopicName();        final Integer qos = data.getQosLevel();        clientSessionCache.asMap().values().stream()                .flatMap(clientSession -> clientSession.topicEntries.stream())                // 发布的主题必须是具体的, 但是订阅的信息是加了通配需要进行正则匹配的.                .filter(entry -> topicName.matches(entry.topicNameRegex))                // 过滤qos                .filter(topicEntry -> topicEntry.requestedQos >= qos)                .forEach(topicEntry -> {                    final ClientSession clientSession = Optional.ofNullable(clientSessionCache.getIfPresent(topicEntry.clientId)).orElseThrow(RuntimeException::new);                    // 根据当前订阅方的clientId的id池获取最新的唯一packetId                    final int newPacketId = clientSession.incrPacketIdAndGet();                    // 降级qos                    data.setQosLevel(topicEntry.requestedQos);                    // 重新设置packetId(针对当前订阅方的id池)                    data.setPacketIdentifier(newPacketId);                    final ByteBuf processedBuffer = mqttParser.encode(data, topicEntry.channel);                    final String hex = ByteBufUtils.buffer2HexNonRead(processedBuffer);                    logger.info("[data: [{}] transfer => sub: [{}] topic: [{}] qos: [{}]]",                            hex, topicEntry.clientId, topicName, topicEntry.requestedQos);                    clientSession.bindPayload(ClientSession.PacketIdPayloadEntry.builder()                            .packetId(newPacketId)                            .timestamp(System.currentTimeMillis())                            // 保留一下, 否则定时那边就被回收了.                            .payload(processedBuffer.retain())                            .build());                    topicEntry.channel.writeAndFlush(processedBuffer);                });    }    public void createClientSession(MqttConnectPacket mqttConnectPacket, Channel channel) {        final String clientId = mqttConnectPacket.getClientId();        channel.attr(CLIENT_ID_ATTRIBUTE_KEY).set(clientId);        clientSessionCache.put(clientId, new ClientSession(clientId, channel));    }    public void bindTopic(MqttTopicFilterPacket topicFilterPacket, Channel channel) {        final Integer requestedQos = topicFilterPacket.getRequestedQos();        final String topicName = topicFilterPacket.getTopicFilter();        final String clientId = channel.attr(CLIENT_ID_ATTRIBUTE_KEY).get();        final AtomicReference<String> topicReference = new AtomicReference<>(topicName                // 处理"/"的转义                .replaceAll("/", "\\\\/")                // 处理多层通配                .replaceAll("#", "\\.*")                // 处理单层通配                .replaceAll("\\+", "[^/]+")                + "$");        Optional.ofNullable(clientSessionCache.get(clientId, cid -> new ClientSession(cid, channel))).ifPresent(clientSession ->                clientSession.bindTopic(ClientSession.TopicEntry.builder()                        .clientId(clientId)                        .requestedQos(requestedQos)                        .topicNameRegex(topicReference.get())                        .channel(channel)                        .build())        );    }    public void unbind(Channel channel) {        final String clientId = channel.attr(CLIENT_ID_ATTRIBUTE_KEY).get();        clientSessionCache.invalidate(clientId);    }    public void unbindPacketId(Channel channel, Integer packetId) {        final String clientId = channel.attr(CLIENT_ID_ATTRIBUTE_KEY).get();        Optional.ofNullable(clientSessionCache.getIfPresent(clientId)).ifPresent(clientSession -> {            clientSession.unbindPayload(packetId);        });    }    public void unbindTopic(Channel channel, String topic) {        final String clientId = channel.attr(CLIENT_ID_ATTRIBUTE_KEY).get();        Optional.ofNullable(clientSessionCache.getIfPresent(clientId)).ifPresent(clientSession -> {            clientSession.unbindTopic(topic);        });    }    @Getter    public static class ClientSession {        private String clientId;        private Channel channel;        private List<TopicEntry> topicEntries;        private List<PacketIdPayloadEntry> packetIdPayloadEntries;        /** 记录当前订阅方的packetId */        private AtomicInteger currentPacketId = new AtomicInteger(1);        public ClientSession(String clientId, Channel channel) {            this.clientId = clientId;            this.channel = channel;            topicEntries = new ArrayList<>();            packetIdPayloadEntries = new ArrayList<>();        }        public int incrPacketIdAndGet() {            int currentPacketIntValue = currentPacketId.incrementAndGet();            while (packetIdPayloadEntries.stream().anyMatch(entry -> entry.getPacketId() == currentPacketId.intValue())){                currentPacketIntValue =  currentPacketId.incrementAndGet();            }            return currentPacketIntValue;        }        public synchronized void bindTopic(TopicEntry topicEntry) {            topicEntries.add(topicEntry);        }        public synchronized void unbindTopic(String topic) {            topicEntries.removeIf(entry -> topic.matches(entry.topicNameRegex));        }        public synchronized void bindPayload(PacketIdPayloadEntry payloadEntry) {            packetIdPayloadEntries.add(payloadEntry);        }        public synchronized void unbindPayload(int packetId) {            packetIdPayloadEntries.removeIf(entry -> {                // 由于之前retain保留了ByteBuf, 在移除待重发的payload时需要release释放.                ReferenceCountUtil.release(entry.getPayload());                return entry.packetId == packetId;            });        }        @Builder        @Getter        public static class TopicEntry {            // 这里备份一份clientId的副本            private String clientId;            private String topicNameRegex;            private Integer requestedQos;            private Channel channel;        }        @Builder        @Getter        public static class PacketIdPayloadEntry {            private Integer packetId;            private long timestamp;            private ByteBuf payload;        }    }}